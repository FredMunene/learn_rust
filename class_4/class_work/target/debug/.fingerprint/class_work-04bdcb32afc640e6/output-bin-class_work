{"$message_type":"diagnostic","message":"ambiguous associated type","code":{"code":"E0223","explanation":"An attempt was made to retrieve an associated type, but the type was ambiguous.\n\nErroneous code example:\n\n```compile_fail,E0223\ntrait Trait { type X; }\n\nfn main() {\n    let foo: Trait::X;\n}\n```\n\nThe problem here is that we're attempting to take the associated type of `X`\nfrom `Trait`. Unfortunately, the type of `X` is not defined, because it's only\nmade concrete in implementations of the trait. A working version of this code\nmight look like:\n\n```\ntrait Trait { type X; }\n\nstruct Struct;\nimpl Trait for Struct {\n    type X = u32;\n}\n\nfn main() {\n    let foo: <Struct as Trait>::X;\n}\n```\n\nThis syntax specifies that we want the associated type `X` from `Struct`'s\nimplementation of `Trait`.\n\nDue to internal limitations of the current compiler implementation we cannot\nsimply use `Struct::X`.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":420,"byte_end":432,"line_start":24,"line_end":24,"column_start":15,"column_end":27,"is_primary":true,"text":[{"text":"        name: String::from{s: \"kenn\"},","highlight_start":15,"highlight_end":27}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if there were a trait named `Example` with associated type `from` implemented for `String`, you could use the fully-qualified path","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":420,"byte_end":432,"line_start":24,"line_end":24,"column_start":15,"column_end":27,"is_primary":true,"text":[{"text":"        name: String::from{s: \"kenn\"},","highlight_start":15,"highlight_end":27}],"label":null,"suggested_replacement":"<String as Example>::from","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0223]\u001b[0m\u001b[0m\u001b[1m: ambiguous associated type\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:24:15\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m24\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        name: String::from{s: \"kenn\"},\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: if there were a trait named `Example` with associated type `from` implemented for `String`, you could use the fully-qualified path\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m24\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        name: \u001b[0m\u001b[0m\u001b[38;5;10m<String as Example>::from\u001b[0m\u001b[0m{s: \"kenn\"},\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m               \u001b[0m\u001b[0m\u001b[38;5;10m~~~~~~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 1 previous error","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: aborting due to 1 previous error\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"For more information about this error, try `rustc --explain E0223`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mFor more information about this error, try `rustc --explain E0223`.\u001b[0m\n"}
